
import type { LinkedRecord, Comment, Rating, Notification, UserProfile } from '@/types';
import { 
  mockLinkedRecords, 
  mockComments, 
  mockRatings, 
  mockNotifications,
  mockUserProfiles 
} from '@/data/mockInteractions';

// READ operations
export const fetchRelatedRecords = async (
  recordId: string,
  recordType: 'company' | 'hospital' | 'user' | 'contact' | 'physician'
): Promise<LinkedRecord[]> => {
  // This would be replaced with actual API call when Supabase is connected
  return mockLinkedRecords.filter(
    record => 
      (record.source_id === recordId && record.source_type === recordType) ||
      (record.target_id === recordId && record.target_type === recordType)
  );
};

export const fetchCommentsForRecord = async (
  recordId: string,
  recordType: 'company' | 'hospital' | 'user' | 'contact' | 'physician'
): Promise<Comment[]> => {
  // This would be replaced with actual API call when Supabase is connected
  return mockComments.filter(
    comment => comment.record_id === recordId && comment.record_type === recordType
  );
};

export const fetchRatingsForRecord = async (
  recordId: string,
  recordType: 'company' | 'hospital' | 'user' | 'contact' | 'physician'
): Promise<Rating[]> => {
  // This would be replaced with actual API call when Supabase is connected
  return mockRatings.filter(
    rating => rating.record_id === recordId && rating.record_type === recordType
  );
};

export const fetchUserNotifications = async (userId: string): Promise<Notification[]> => {
  // This would be replaced with actual API call when Supabase is connected
  return mockNotifications.filter(notification => notification.user_id === userId);
};

export const fetchUserProfile = async (userId: string): Promise<UserProfile | null> => {
  // This would be replaced with actual API call when Supabase is connected
  const profile = mockUserProfiles.find(profile => profile.user_id === userId);
  return profile || null;
};

// CREATE operations
export const createComment = async (
  content: string,
  recordId: string,
  recordType: 'company' | 'hospital' | 'user' | 'contact' | 'physician',
  userId: string,
  parentId?: string
): Promise<Comment> => {
  // This would be replaced with actual API call when Supabase is connected
  const newComment: Comment = {
    id: `new-${Date.now()}`, // Would be generated by the database
    content,
    record_id: recordId,
    record_type: recordType,
    user_id: userId,
    parent_id: parentId,
    upvotes: 0,
    downvotes: 0,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };
  
  // In a real app, this would be saved to the database
  // mockComments.push(newComment);
  
  return newComment;
};

export const createRating = async (
  value: number,
  recordId: string,
  recordType: 'company' | 'hospital' | 'user' | 'contact' | 'physician',
  userId: string,
  notes?: string
): Promise<Rating> => {
  // This would be replaced with actual API call when Supabase is connected
  const newRating: Rating = {
    id: `new-${Date.now()}`, // Would be generated by the database
    value,
    record_id: recordId,
    record_type: recordType,
    user_id: userId,
    notes,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };
  
  // In a real app, this would be saved to the database
  // mockRatings.push(newRating);
  
  return newRating;
};

export const createLinkedRecord = async (
  sourceId: string,
  sourceType: 'company' | 'hospital' | 'user' | 'contact' | 'physician',
  targetId: string,
  targetType: 'company' | 'hospital' | 'user' | 'contact' | 'physician',
  relationshipType: string,
  userId: string,
  notes?: string
): Promise<LinkedRecord> => {
  // This would be replaced with actual API call when Supabase is connected
  const newLinkedRecord: LinkedRecord = {
    id: `new-${Date.now()}`, // Would be generated by the database
    source_id: sourceId,
    source_type: sourceType,
    target_id: targetId,
    target_type: targetType,
    relationship_type: relationshipType,
    notes,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    created_by: userId,
    last_modified_by: userId
  };
  
  // In a real app, this would be saved to the database
  // mockLinkedRecords.push(newLinkedRecord);
  
  return newLinkedRecord;
};

// UPDATE operations
export const updateComment = async (
  commentId: string,
  updates: { content?: string; upvotes?: number; downvotes?: number }
): Promise<Comment | null> => {
  // This would be replaced with actual API call when Supabase is connected
  const comment = mockComments.find(comment => comment.id === commentId);
  if (!comment) return null;
  
  const updatedComment = {
    ...comment,
    ...updates,
    updated_at: new Date().toISOString()
  };
  
  // In a real app, this would update the database
  // const index = mockComments.findIndex(c => c.id === commentId);
  // mockComments[index] = updatedComment;
  
  return updatedComment;
};

export const updateRating = async (
  ratingId: string,
  updates: { value?: number; notes?: string }
): Promise<Rating | null> => {
  // This would be replaced with actual API call when Supabase is connected
  const rating = mockRatings.find(rating => rating.id === ratingId);
  if (!rating) return null;
  
  const updatedRating = {
    ...rating,
    ...updates,
    updated_at: new Date().toISOString()
  };
  
  // In a real app, this would update the database
  // const index = mockRatings.findIndex(r => r.id === ratingId);
  // mockRatings[index] = updatedRating;
  
  return updatedRating;
};

// DELETE operations
export const deleteComment = async (commentId: string): Promise<boolean> => {
  // This would be replaced with actual API call when Supabase is connected
  const exists = mockComments.some(comment => comment.id === commentId);
  if (!exists) return false;
  
  // In a real app, this would delete from the database
  // mockComments = mockComments.filter(comment => comment.id !== commentId);
  
  return true;
};

export const deleteRating = async (ratingId: string): Promise<boolean> => {
  // This would be replaced with actual API call when Supabase is connected
  const exists = mockRatings.some(rating => rating.id === ratingId);
  if (!exists) return false;
  
  // In a real app, this would delete from the database
  // mockRatings = mockRatings.filter(rating => rating.id !== ratingId);
  
  return true;
};

export const deleteLinkedRecord = async (linkedRecordId: string): Promise<boolean> => {
  // This would be replaced with actual API call when Supabase is connected
  const exists = mockLinkedRecords.some(record => record.id === linkedRecordId);
  if (!exists) return false;
  
  // In a real app, this would delete from the database
  // mockLinkedRecords = mockLinkedRecords.filter(record => record.id !== linkedRecordId);
  
  return true;
};

// Specialized queries
export const fetchThreadedComments = async (
  recordId: string,
  recordType: 'company' | 'hospital' | 'user' | 'contact' | 'physician'
): Promise<Comment[]> => {
  const comments = await fetchCommentsForRecord(recordId, recordType);
  
  // Group comments by parent_id
  const commentsByParentId: Record<string, Comment[]> = {};
  comments.forEach(comment => {
    if (comment.parent_id) {
      if (!commentsByParentId[comment.parent_id]) {
        commentsByParentId[comment.parent_id] = [];
      }
      commentsByParentId[comment.parent_id].push(comment);
    }
  });
  
  // Get top-level comments
  const topLevelComments = comments.filter(comment => !comment.parent_id);
  
  // Add replies property to each comment
  const addReplies = (comment: Comment & { replies?: Comment[] }): (Comment & { replies?: Comment[] }) => {
    const withReplies = { ...comment, replies: [] };
    if (commentsByParentId[comment.id]) {
      withReplies.replies = commentsByParentId[comment.id].map(addReplies);
    }
    return withReplies;
  };
  
  return topLevelComments.map(addReplies);
};

export const fetchActivityFeed = async (userId: string, limit = 10): Promise<Notification[]> => {
  // This would be replaced with actual API call when Supabase is connected
  const profile = await fetchUserProfile(userId);
  if (!profile) return [];
  
  const followingIds = profile.following_records?.map(record => record.id) || [];
  
  // Get notifications related to followed records
  const relevantNotifications = mockNotifications.filter(notification => 
    notification.user_id === userId || 
    (notification.record_id && followingIds.includes(notification.record_id))
  );
  
  // Sort by date, newest first
  return relevantNotifications
    .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
    .slice(0, limit);
};

export const markNotificationAsRead = async (notificationId: string): Promise<boolean> => {
  // This would be replaced with actual API call when Supabase is connected
  const notification = mockNotifications.find(n => n.id === notificationId);
  if (!notification) return false;
  
  // In a real app, this would update the database
  // const index = mockNotifications.findIndex(n => n.id === notificationId);
  // mockNotifications[index] = { ...notification, read: true };
  
  return true;
};

export const updateUserPoints = async (
  userId: string, 
  pointsChange: number
): Promise<UserProfile | null> => {
  // This would be replaced with actual API call when Supabase is connected
  const profile = mockUserProfiles.find(profile => profile.user_id === userId);
  if (!profile) return null;
  
  const updatedProfile = {
    ...profile,
    points: profile.points + pointsChange,
    updated_at: new Date().toISOString()
  };
  
  // In a real app, this would update the database
  // const index = mockUserProfiles.findIndex(p => p.user_id === userId);
  // mockUserProfiles[index] = updatedProfile;
  
  return updatedProfile;
};

export const updateUserPreferences = async (
  userId: string,
  preferences: Record<string, any>
): Promise<UserProfile | null> => {
  // This would be replaced with actual API call when Supabase is connected
  const profile = mockUserProfiles.find(profile => profile.user_id === userId);
  if (!profile) return null;
  
  const updatedProfile = {
    ...profile,
    preferences: { ...profile.preferences, ...preferences },
    updated_at: new Date().toISOString()
  };
  
  // In a real app, this would update the database
  // const index = mockUserProfiles.findIndex(p => p.user_id === userId);
  // mockUserProfiles[index] = updatedProfile;
  
  return updatedProfile;
};
